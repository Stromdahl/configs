# ~/.bashrc

# =============================================================================
# - ENVIRONMENT SETUP
# =============================================================================

# Preferred editor
export EDITOR=nvim

# Default file permissions
umask 022

# Add custom local bin to PATH
export PATH="$HOME/.local/bin:$PATH"

# Less colors and options
export LESS="-FRSX"

# Enable color support for `ls` and other commands
if [ -x /usr/bin/dircolors ]; then
    eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# =============================================================================
# - SHELL OPTIONS
# =============================================================================

# Make bash append to the history file instead of overwriting it
shopt -s histappend

# Check window size after each command and update LINES and COLUMNS
shopt -s checkwinsize

# Extended globbing
shopt -s extglob

# Case-insensitive globbing
shopt -s nocaseglob

# Enable command autocorrection (mild)
shopt -s dirspell cdspell


# =============================================================================
# - HISTORY BEHAVIOR
# =============================================================================

export HISTSIZE= #keep forever
export HISTFILESIZE= #keep forever
export HISTCONTROL=ignoredups:erasedups
export HISTIGNORE="ls:cd:pwd:exit:clear"

# =============================================================================
# - CUSTOM OPTIONS
# =============================================================================

# change man display to unhyphenated and ragged-right
MANOPT="--nh --nj"

# make less use colors, i. e. in man
export LESS_TERMCAP_mb=$'\e[1;32m'
export LESS_TERMCAP_md=$'\e[1;32m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;31m'

export TRASH_DIR="$HOME/.trash"

# =============================================================================
# - PROMPT (PS1) CONFIGURATION
# =============================================================================

# Försök ladda git-prompt så __git_ps1 finns
if [ -z "${__GIT_PROMPT_SOURCED:-}" ]; then
  for f in /usr/share/git/completion/git-prompt.sh \
           /etc/bash_completion.d/git-prompt \
           /usr/local/etc/bash_completion.d/git-prompt; do
    [ -r "$f" ] && . "$f" && __GIT_PROMPT_SOURCED=1 && break
  done
fi

__prompt_command() {
  local exit_code=$?

  # Färger/sekvenser
  local RED="\[\033[91m\]"
  local GREEN="\[\033[92m\]"
  local YELLOW="\[\033[93m\]"
  local BLUE="\[\033[94m\]"
  local PURPLE="\[\033[95m\]"
  local CYAN="\[\033[96m\]"
  local GRAY="\[\033[37m\]"
  local RESET="\[\033[0m\]"
  local BOLD="\[\033[1m\]"
  local BELL="\[\a\]"

  # Exitstatus
  local status=""
  if [ $exit_code -ne 0 ]; then
    status="[$exit_code] "
  fi

  # Git-branch (färgad efter rent/smutsigt arbets­träd)
  local branch=""
  if type __git_ps1 >/dev/null 2>&1; then
    branch="$(__git_ps1)"
  else
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"
      [ "$branch" = "HEAD" ] && branch="$(git describe --tags --always 2>/dev/null)"
      [ -n "$branch" ] && branch="($branch)"
    fi
  fi

  local gitbranch=""
  if [ -n "$branch" ]; then
    if git diff --quiet 2>/dev/null && git diff --cached --quiet 2>/dev/null; then
      gitbranch="${YELLOW}${branch}${RESET}"
    else
      gitbranch="${PURPLE}${branch}${RESET}"
    fi
  fi

  # Sökväg: relativt repo­roten i git, annars \w
  local path=""
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local git_root prefix repo
    git_root="$(git rev-parse --show-toplevel 2>/dev/null)"
    prefix="$(git rev-parse --show-prefix 2>/dev/null)"   # t.ex. "src/lib/"
    repo="${git_root##*/}"                                # endast katalognamn
    if [ -n "$prefix" ]; then
      path="${repo}/${prefix%/}"                          # "repo/src/lib"
    else
      path="${repo}"                                      # "repo"
    fi
  else
    path="\w"
  fi

  local count="\#"
  local end="\$"
  local TITLE="\[\e]0;\u@\h: \w\a\]"

  PS1="${TITLE}${RED}${status}${CYAN}${count}${gitbranch} ${BLUE}${path}\n${GRAY}${end}${RESET} "
}

PROMPT_DIRTRIM=3
export PROMPT_COMMAND="__prompt_command"

# =============================================================================
# - CUSTOM FUNCTIONS
# =============================================================================

# Extract most common archive types
function extract () {
    if [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1" ;;
            *.tar.gz)    tar xzf "$1" ;;
            *.bz2)       bunzip2 "$1" ;;
            *.rar)       unrar x "$1" ;;
            *.gz)        gunzip "$1" ;;
            *.tar)       tar xf "$1" ;;
            *.tbz2)      tar xjf "$1" ;;
            *.tgz)       tar xzf "$1" ;;
            *.zip)       unzip "$1" ;;
            *.Z)         uncompress "$1" ;;
            *.7z)        7z x "$1" ;;
            *)           echo "Cannot extract '$1' - unknown archive type" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Create directory and enter it
function mkcd () {
    mkdir -p "$1" && cd "$1"
}

# Search running processes
function psearch () {
    ps aux | grep -i "$1" | grep -v grep
}


function generate_password() {
	local l=$1
       	[ "$l" == "" ] && l=32
      	tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
}

# Kill and Remove all docker containers
function docker_kill() {
  (docker stop $(docker ps -aq) 2>/dev/null && docker rm -f $(docker ps -aq) 2>/dev/null)
}
function __move_to_trash() {
  mkdir -p "$TRASH_DIR"
  for f in "$@"; do
    if [ -e "$f" ]; then
      mv -v "$f" "$TRASH_DIR/"
    else
      echo "tr: '$f' does not exist" >&2
    fi
  done
}

if [ ! -S ~/.ssh/ssh_auth_sock ]; then
  eval `ssh-agent -t 28800` > /dev/null 2>&1
  ln -sf "$SSH_AUTH_SOCK" ~/.ssh/ssh_auth_sock
fi
function __ssh-sk() {
  if ! lsusb | grep -q 1050:0407; then
      echo "Hardware security key not found or no resident SSH key present!"
      echo "Insert your hardware security key and try again."
      return
  fi
  
  if ! ssh-add -L 2>/dev/null | grep -q 'sk-'; then
      SSH_ADD_OUTPUT=$(ssh-add -K 2>&1)
      if [ $? -ne 0 ]; then
          echo "Unable to load resident SSH key from hardware security key"
          echo "Reason: $SSH_ADD_OUTPUT"
          return
      fi
  fi
  
  printf "Touch your security key when blinking...\n">&2
  /usr/bin/ssh "$@"
}

function cdgr() {
  local inside_git_repo="$(git rev-parse --is-inside-work-tree 2>/dev/null)"
  if [ "$inside_git_repo" ]; then
    cd $(git rev-parse --show-toplevel)
  fi
}

# =============================================================================
# - ALIASES
# =============================================================================

alias ....='cd ../../..'
alias ...='cd ../..'
alias ..='cd ..'
alias la='ll -A'
alias ll='ls -hltF --time-style=long-iso --group-directories-first'
alias please='sudo !!'
alias reload='source ~/.bashrc'
alias ssh="__ssh-sk"
alias update='sudo apt update && sudo apt upgrade -y'
alias week='date +%V'
alias rr='__move_to_trash'

# Safer operations
alias cp='cp -vi'
alias mv='mv -vi'
alias rm='rm -vi'
# Networking
alias ports='ss -ptunl | fzf'

# Git shortcuts
alias gs='git status --short'
alias gsi='git status --short --ignored'
alias glg='git log --graph --oneline --branches --tags --remotes'

# Aliases for xclip
alias xci='xclip -rmlastnl -in -selection  clipboard'
alias xcie='xci <<<' # Works line "echo" but for clipboard
alias xcif='xci <' # Reads a file to clipboard
alias xco='xclip -out -selection clipboard'
alias xcpi='xclip -in'
alias xcpo='xclip -out'

# Quality of life
alias publicip='curl -s http://ifconfig.me/all.json | jq -r .ip_addr'
alias pubkey='cat $HOME/.ssh/id_ed25519_sk_rk.pub';
# TODO: This should be moved to ~.dotfiles/bin/inode
alias inode='node /home/ms/development/javascript/inode'

alias compose="docker compose"

# Work journal
alias daily='nvim ~/notes/daily.md'

#
# =============================================================================
# - FZF 
# =============================================================================
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

# fbr - checkout git branch
gbfzf() {
  local branches branch
  branches=$(git --no-pager branch -vv) &&
  branch=$(echo "$branches" | fzf +m) &&
  git checkout $(echo "$branch" | awk '{print $1}' | sed "s/.* //")
}

# fbr - checkout git branch
p() {
  ps aux | fzf --tiebreak=length | awk '{print($2)}'
}

# =============================================================================
# - DEVELOPER ENVIRONMENT
# =============================================================================
export SSH_AUTH_SOCK=~/.ssh/ssh_auth_sock

# Rust (via rustup)
export PATH="$HOME/.cargo/bin:$PATH"

# Python virtual environments
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
[ -f /usr/local/bin/virtualenvwrapper.sh ] && source /usr/local/bin/virtualenvwrapper.sh

# =============================================================================
# - FINAL SETUP
# =============================================================================

# Source user local bashrc if it exists
[ -f "$HOME/.bashrc.local" ] && source "$HOME/.bashrc.local"

